## Online 3D bin packing

本專案的軟體部分可歸類為**Online Bin Packing (Online BPP)** 問題，即需依當下所見的物品大小進行裝箱任務。在本專案中，需要設計一演算法使用機器手臂將一系列長方體物品逐個裝入固定大小的物流籠車中，目標是盡量減少空間浪費並確保穩定性，期望達到比人工裝箱更快，裝載率更高。在在線場景中，物品按順序從輸送帶到達，必須在不知道未來物品的情況下即時完成決策。目前實現了基於**啟發式規則 (Heuristics)** 與於**蒙地卡羅搜尋(Monte Carlo tree search)** 的版本，模擬了從感知貨物、決策放置到更新狀態的完整流程。演算法的核心是 **Bottom-Left 策略**，並結合了多種物理約束條件，以確保裝箱方案的現實可行性。


## 檔案結構
```
3DBPP
├── main.py                 # (主程式)
├── config.py               # (設定檔)
└── bpp_solver/             # (核心演算法模組)
    ├── data_structures.py  # (定義資料結構)
    ├── geometry.py         # (幾何計算工具)
    ├── constraints.py      # (重量、支撐面積與重心限制)
    ├── surface_manager.py  # (支撐平面管理器)
    ├── scoring.py          # (為放置方案評分)
        z最小-> y最小 -> x最小
    ├── box_gen.py          # (生成測試用資料csv)
    └── packer.py           # (裝箱決策者)
 ```   

## 核心功能
目前使用Bottom-Left，掃描上方平面，根據評分函數選擇最佳放置位置，並切割平面生成新平面
*   **Bottom-Left** 策略，以z最小-> y最小 -> x最小 順序遍歷所有左下角點放置。
*   **hard- constraints**:
    *   **尺寸與重量**: 確保貨物不超出籠車邊界(不允許超高堆疊)且不超重。
    *   **接觸面積穩定度**: 貨物底部與支撐面的接觸面積必須達到設定的最小比例 (`STABILITY_FACTOR` = 0.75)。
![image](https://hackmd.io/_uploads/HJzhD6aUxx.png)
    *   (**物品自身穩定度**: 貨物的重心投影必須落在其下方的支撐平面內，防止自身翻倒。)
    *   **籠車整體穩定度**: 放置後，整個籠車的總重心必須保持在底部的安全區域內。
*   **動態支撐平面管理**:

![image](https://hackmd.io/_uploads/SyqasOhUlg.png)

*   每次放置後，系統會自動**切割**被佔用的舊平面，並在貨物頂部**創建**新平面，最後將相鄰且同高的平面合併，合併平面容許小幅度的誤差，可自行調適參數。
*   **可配置性**: 所有關鍵參數（如籠車尺寸、誤差、穩定度因子）都集中在 `config.py` 中，方便管理與調整。
*   **資料驅動**: 支援從 `.csv` 檔案讀取貨物清單，方便進行測試和驗證。
 
## Install 
```
To make this project work, there are two things you should do:
* Install Python packages in 'requirements.py' (by 'pip install -r requirements.txt').
* (This code works on Python 3.11)
```
## Run
we provide a unified interface in 'main.py', please run with the example dataset 'conveyor_items.csv'
```
python -m bpp_solver.runners.run_cp_heuristics
python -m bpp_solver.runners.run_cp_mcts
python -m bpp_solver.runners.run_ems_heuristics
python -m bpp_solver.runners.run_ems_mcts

# 主迴圈的執行流程
# 讀入csv檔作為輸送帶清單物品-> 
# 每次遍歷前四個貨物，呼叫 packer.py 選擇最佳放置方案->
# 繪製可視化3D圖
```

## api design
為利於系統整合、自動化控制與未來擴展，本研究以 FastAPI 框架開發了一套 RESTful API，名為”3D Bin Packing API"。此 API 將複雜的裝箱演算法封裝為標準化的網路服務，以便與操作者和機械手臂控制程式互動，並由伺服器統一管理籠車的即時狀態。
本 API 提供以下三項核心功能：
POST/start_packing
●	功能說明: 考量到籠車可能具有不同大小，本端點用於初始化籠車實例。客戶端需輸入籠車尺寸或參數，伺服器將建立對應的籠車狀態並進行管理。
●	核心演算法: 伺服器依據輸入的籠車參數建立 cage物件，並初始化其內部空間結構，作為後續放置決策的基準。
●	回傳: 籠車初始化成功訊息與籠車物件狀態

GET/get_cage_state
●	功能說明: 回傳目前籠車的即時狀態，包括籠車尺寸、剩餘容量、已放置物品資訊等。
●	核心演算法: 直接讀取伺服器維護的 cage 狀態，不涉及演算法求解。
●	回傳：籠車物件狀態

POST/decide_next_move
●	功能說明: 此為 API 的決策核心。客戶端提供一組候選貨物，伺服器將根據輸入的搜尋策略與放置點生成策略呼叫對應方法組合的裝箱選擇器，裝箱選擇器會基於當前的籠車狀態，選擇最佳放置方案（包含物品編號、位置與旋轉方向）。若找到可行解，伺服器會自動更新籠車狀態。
●	核心演算法: 根據輸入的 strategy 與 algorithm執行3.3 節所述之演算法，實例化對應的 Packer 物件。
●	呼叫 Packer.pack() 方法，傳入伺服器當前的 cage_instance 與候選貨物 candidate_items。
●	Packer 內部會進行最佳放置方案搜尋、約束檢查與評分，成功找到方案後，呼叫 execute_placement 更新伺服器上的籠車狀態。
●	回傳: 最佳放置方案並更新籠車狀態
 

## Result Demo
**資料集**
```
id,base_dimensions,weight,allowed_rotations,is_fragile
1,"(57, 67, 67)",34.3,"[0,1,2,3,4,5]",False
2,"(57, 57, 47)",30.9,"[0,1,2,3,4,5]",False
3,"(57, 37, 47)",24.5,"[0,1,2,3,4,5]",False
4,"(57, 37, 47)",24.5,"[0,1,2,3,4,5]",False
5,"(77, 37, 37)",21.1,"[0,1,2,3,4,5]",False
6,"(37, 37, 47)",16.4,"[0,1,2,3,4,5]",False
7,"(37, 37, 47)",16.4,"[0,1,2,3,4,5]",False
8,"(77, 17, 27)",11.5,"[0,1,2,3,4,5]",False
9,"(77, 17, 27)",11.5,"[0,1,2,3,4,5]",False
10,"(57, 17, 27)",9.2,"[0,1,2,3,4,5]",False
11,"(57, 17, 27)",9.2,"[0,1,2,3,4,5]",False
12,"(37, 17, 27)",6.9,"[0,1,2,3,4,5]",False
13,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
14,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
15,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
16,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
17,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
18,"(27, 27, 17)",4.1,"[0,1,2,3,4,5]",False
19,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
20,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
21,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
22,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
23,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
24,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
25,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
26,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
27,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
28,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
29,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
30,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
```
### case1 隨機亂數生成:
```
# params
NUM_ITEMS = 10  # 生成的物品數量
ITEM_DIMENSIONS_RANGE = {
    'length': (10, 100),  # 單位: cm
    'width': (1, 100),   # 單位: cm
    'height': (10, 100),   # 單位: cm
    'weight': (1, 30)  # 單位: kg
}

id,base_dimensions,weight,allowed_rotations,is_fragile
1,"(60, 70, 50)",40,"[0,1,2,3,4,5]",False
2,"(45, 30, 60)",40,"[0,1,2,3,4,5]",False
3,"(35, 35, 60)",50,"[0,1,2,3,4,5]",False
4,"(50, 60, 80)",30,"[0,1,2,3,4,5]",False
5,"(10, 80, 20)",20,"[0,1,2,3,4,5]",False
6,"(20, 20, 20)",30,"[0,1,2,3,4,5]",False
7,"(20, 20, 80)",40,"[0,1,2,3,4,5]",False
8,"(80, 10, 10)",10,"[0,1,2,3,4,5]",False
9,"(40, 40, 40)",20,"[0,1,2,3,4,5]",False
10,"(50, 50, 50)",30,"[0,1,2,3,4,5]",False
```
![image](https://hackmd.io/_uploads/rydA4vkDge.png)

### 籠車空間利用率: 40.60%, 放置物品 8/10 
物品id = 4: 因為**支撐面積不足以確保穩定性**、**超出籠車邊界**
物品id = 10: 因為**超過籠車重量限制**、**超出籠車邊界**、**放置物品後籠車重心不穩定**等原因無法被機器手臂放入

### case2 自訂資料，物品的尺寸被設計成可以相互整除或匹配:
```
id,base_dimensions,weight,allowed_rotations,is_fragile
1,"(57, 67, 67)",34.3,"[0,1,2,3,4,5]",False
2,"(57, 57, 47)",30.9,"[0,1,2,3,4,5]",False
3,"(57, 37, 47)",24.5,"[0,1,2,3,4,5]",False
4,"(57, 37, 47)",24.5,"[0,1,2,3,4,5]",False
5,"(77, 37, 37)",21.1,"[0,1,2,3,4,5]",False
6,"(37, 37, 47)",16.4,"[0,1,2,3,4,5]",False
7,"(37, 37, 47)",16.4,"[0,1,2,3,4,5]",False
8,"(77, 17, 27)",11.5,"[0,1,2,3,4,5]",False
9,"(77, 17, 27)",11.5,"[0,1,2,3,4,5]",False
10,"(57, 17, 27)",9.2,"[0,1,2,3,4,5]",False
11,"(57, 17, 27)",9.2,"[0,1,2,3,4,5]",False
12,"(37, 17, 27)",6.9,"[0,1,2,3,4,5]",False
13,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
14,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
15,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
16,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
17,"(27, 27, 27)",5.4,"[0,1,2,3,4,5]",False
18,"(27, 27, 17)",4.1,"[0,1,2,3,4,5]",False
19,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
20,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
21,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
22,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
23,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
24,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
25,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
26,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
27,"(17, 17, 17)",2.2,"[0,1,2,3,4,5]",False
28,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
29,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
30,"(7, 7, 7)",2.2,"[0,1,2,3,4,5]",False
```
### 1. 貨物來時按體積降冪排序(最佳情況):
![image_d](img/case_2_descending.png)
### 籠車空間利用率: 93.00%, 放置物品 29/30 

### 2. 貨物來時按體積升冪排序(最差情況):
![image_a](img/case_2_ascending.png)
### 籠車空間利用率: 38.67%, 放置物品 25/30 

### 3. 貨物來時亂序(實際情況):
![image_r](img/case_2_random_order.png)
### 籠車空間利用率: 72.93%,  放置物品 27/30 

```
